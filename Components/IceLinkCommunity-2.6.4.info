{"Name":"IceLink Community","Id":1886,"Alias":"IceLinkCommunity","Description":"## What is IceLink for Xamarin?\r\n\r\nIceLink for Xamarin allows you to add core audio/video capabilities to your Xamarin application â€“ capabilities that you can control from within your application. IceLink complies with the WebRTC standard so your Xamarin applications can interact seamlessly and plugin-free with WebRTC-enabled browsers like Chrome, FireFox and Opera.\r\n\r\n## Complete audio and video engines.\r\n\r\nIceLink implements the WebRTC standard for audio/video streams, including media capture, media playback, stream formatting, RTP/RTCP packet processing, audio/video encoding/decoding (Opus, G.711, VP8), and more.\r\n\r\n## Use any signalling system.\r\n\r\nAs IceLink follows the WebRTC standard, it requires a separate signalling mechanism to locate the peer before it can establish a peer-to-peer connection. Signalling for IceLink is provided by Frozen Mountain\u0027s WebSync product or your own application if you already have a real-time messaging component (an XMPP or WebSocket library, for example). The samples included in this component use a public WebSync signalling engine running continuously on Frozen Mountain\u0027s servers.\r\n\r\n## Cross-platform support.\r\n\r\nIceLink is available for all major desktop (PC, Mac, Linux), mobile (iOS, Android, Windows Phone), and web platforms (Chrome, Internet Explorer, Firefox, Safari, Opera).\r\n\r\nThis is the Community Edition of IceLink, licensed for non-commercial use. WAN connections are terminated automatically after 30 seconds. LAN connections have no restrictions. The [Enterprise Edition](http://www.frozenmountain.com/purchase#icelink) is licensed for commercial applications.","Version":"2.6.4","Summary":"WebRTC-based peer-to-peer (P2P) audio/video and data streaming.","QuickStart":"Let\u0027s build a video chat that loops back on itself. We need to:\r\n\r\n1. Capture audio and video from the camera and microphone.\r\n2. Show a live preview of the video.\r\n3. Create a P2P connection between two in-memory clients.\r\n4. Play the incoming audio from the network.\r\n5. Display the incoming video from the network.\r\n\r\n## Codecs\r\n\r\nIceLink lets you use any audio or video codec. Out-of-the-box support is provided for VP8 (video), Opus (audio), and G.711 (audio, also known as PCMU/PCMA). \r\n\r\nLet\u0027s use the VP8 video codec:\r\n\r\n    VideoStream.RegisterCodec(\"VP8\", () =\u003e\r\n    {\r\n        return new Vp8Codec();\r\n    }, true);\r\n\r\n... and the Opus audio codec:\r\n\r\n    AudioStream.RegisterCodec(\"opus\", 48000, 2, () =\u003e\r\n    {\r\n        return new OpusCodec();\r\n    }, true);\r\n\r\n## Local Media\r\n\r\nWe need two local media streams - one for the sender and one for the receiver.\r\n\r\nThe sender will be capturing local audio and video:\r\n\r\n    LocalMediaStream senderLocalMedia = null;\r\n    Object senderLocalVideoControl = null;\r\n\r\n    UserMedia.GetMedia(new GetMediaArgs(true, true)\r\n    {\r\n        OnFailure = (e) =\u003e\r\n        {\r\n\t\t\tLog.Error(\"Could not get sender local media.\", e.Exception);\r\n        },\r\n        OnSuccess = (e) =\u003e\r\n        {\r\n            senderLocalMedia = e.LocalStream;\r\n            senderLocalVideoControl = e.LocalVideoControl;\r\n        }\r\n    });\r\n\r\n(Note that we are keeping a reference to something called a \"local video control\". We\u0027ll come back to this later.)\r\n\r\nThe receiver won\u0027t be capturing local audio or video (but we still need a local media stream instance):\r\n\r\n    LocalMediaStream receiverLocalMedia = null;\r\n\r\n    UserMedia.GetMedia(new GetMediaArgs(false, false)\r\n    {\r\n        OnFailure = (e) =\u003e\r\n        {\r\n\t\t\tLog.Error(\"Could not get receiver local media.\", e.Exception);\r\n        },\r\n        OnSuccess = (e) =\u003e\r\n        {\r\n            receiverLocalMedia = e.LocalStream;\r\n        }\r\n    });\r\n\r\n## Stream Descriptions\r\n\r\nNext, we need to describe the data we intend to send or receive over the P2P connections. The sender and receiver need to agree, so we need to describe the streams for both sides.\r\n\r\nFirst, let\u0027s describe the streams we want to send:\r\n\r\n\tvar senderAudioStream = new AudioStream(SenderLocalMedia);\r\n    var senderVideoStream = new VideoStream(SenderLocalMedia);\r\n\r\n... and then describe the streams we want to receive:\r\n\r\n    var receiverAudioStream = new AudioStream(ReceiverLocalMedia);\r\n    var receiverVideoStream = new VideoStream(ReceiverLocalMedia);\r\n\r\n## Conference\r\n\r\nThe Conference is what pulls everything together. You can think of a conference as a client of sorts. The sending side needs a conference:\r\n\r\n    var sender = new Conference(new Stream[]\r\n    {\r\n        senderAudioStream,\r\n        senderVideoStream\r\n    });\r\n\r\n... as does the receiving side:\r\n\r\n    var receiver = new Conference(new Stream[]\r\n    {\r\n        receiverAudioStream,\r\n        receiverVideoStream\r\n    });\r\n\r\n## Signalling\r\n\r\nNow comes a short lesson. In order to create a P2P connection, the two sides have to exchange some information - an \"offer\", an \"answer\", and a few \"candidates\". One side will generate an \"offer\", the other side will respond with an \"answer\", and both sides will generate \"candidates\". The process of passing these messages between the two peers is called **signalling**.\r\n\r\nIn-memory signalling is trivial. When the sender generates an offer/answer or candidate, it simply passes it to the receiver:\r\n\r\n    sender.OnLinkOfferAnswer += (e) =\u003e\r\n    {\r\n        receiver.ReceiveOfferAnswer(e.OfferAnswer, e.PeerId);\r\n    };\r\n    sender.OnLinkCandidate += (e) =\u003e\r\n    {\r\n        receiver.ReceiveCandidate(e.Candidate, e.PeerId);\r\n    };\r\n\r\n... and the receiver does the same in reverse:\r\n\r\n    receiver.OnLinkOfferAnswer += (e) =\u003e\r\n    {\r\n        sender.ReceiveOfferAnswer(e.OfferAnswer, e.PeerId);\r\n    };\r\n    receiver.OnLinkCandidate += (e) =\u003e\r\n    {\r\n        sender.ReceiveCandidate(e.Candidate, e.PeerId);\r\n    };\r\n\r\nIn most applications, you would use a real-time messaging system (like XMPP or WebSync) to exchange this data since the clients wouldn\u0027t exist in the same process. Both the OfferAnswer and Candidate classes include ToJson/FromJson serialization helpers to make this easier.\r\n\r\n## Link\r\n\r\nWe are ready to go! One side simply needs to call the other:\r\n\r\n    sender.Link(\"receiver\");\r\n\r\nLet\u0027s run it!\r\n\r\n## Local Video Control\r\n\r\nBut wait! We hear audio, but we don\u0027t see any video!\r\n\r\nWhat gives?\r\n\r\nIt\u0027s because UI decisions are best left to you. IceLink automatically creates controls to display the live video feeds, but it\u0027s up to you to add them into your user interface.\r\n\r\nRemember that \"local video control\" that we kept a reference to earlier? It\u0027s time to use it. On iOS, the local video control is actually a UIView, and on Android, the local video control is actually a View:\r\n\r\n\t// iOS\r\n    DispatchQueue.MainQueue.DispatchAsync(() =\u003e\r\n    {\r\n        var control = (UIView)localVideoControl;\r\n        var width = SenderContainer.Frame.Width;\r\n        var height = SenderContainer.Frame.Height;\r\n        control.Frame = new RectangleF(0, 0, width, height);\r\n        SenderContainer.AddSubview(control);\r\n    });\r\n\r\n    // Android\r\n    RunOnUiThread(new Action(() =\u003e\r\n    {\r\n        var control = (View)localVideoControl;\r\n        SenderContainer.AddView(control,\r\n\t\t\tnew RelativeLayout.LayoutParams(\r\n                RelativeLayout.LayoutParams.MatchParent,\r\n                RelativeLayout.LayoutParams.MatchParent));\r\n    }));\r\n\r\n(Note that you can add the control anywhere in the view hierachy. For simplicity, we assume that an empty \"SenderContainer\" exists somewhere in your interface definition.)\r\n\r\nLet\u0027s run it again!\r\n\r\n## Remote Video Controls\r\n\r\nHmmm... Now we can see the local sender preview, but what about the video that\u0027s being sent over the network to the receiver?\r\n\r\nAgain, IceLink creates a control to display the live video feed, but leaves the decision about where to put it to you.\r\n\r\nWe can get a reference to the \"remote video control\" as soon as a new link is initializing. Let\u0027s add an event handler to the OnLinkInit event of the \"receiverVideoStream\" we created earlier:\r\n\r\n    receiverVideoStream.OnLinkInit += (e) =\u003e\r\n    {\r\n        // iOS\r\n        DispatchQueue.MainQueue.DispatchAsync(() =\u003e\r\n        {\r\n            var control = (UIView)e.Link.GetRemoteVideoControl();\r\n\t        var width = ReceiverContainer.Frame.Width;\r\n\t        var height = ReceiverContainer.Frame.Height;\r\n\t        control.Frame = new RectangleF(0, 0, width, height);\r\n\t        ReceiverContainer.AddSubview(control);\r\n        });\r\n\r\n\t\t// Android\r\n        RunOnUiThread(new Action(() =\u003e\r\n        {\r\n            var control = (View)e.Link.GetRemoteVideoControl();\r\n\t        ReceiverContainer.AddView(control,\r\n\t\t\t\tnew RelativeLayout.LayoutParams(\r\n\t                RelativeLayout.LayoutParams.MatchParent,\r\n\t                RelativeLayout.LayoutParams.MatchParent));\r\n        }));\r\n    };\r\n\r\nLikewise, to remove the control from the UI when the link goes down, we add an event handler to the OnLinkDown event:\r\n\r\n    receiverVideoStream.OnLinkDown += (e) =\u003e\r\n    {\r\n        DispatchQueue.MainQueue.DispatchAsync(() =\u003e\r\n        {\r\n\t\t\t// iOS\r\n            var control = (UIView)e.Link.GetRemoteVideoControl();\r\n            control.RemoveFromSuperview();\r\n\r\n\t\t\t// Android\r\n            var control = (View)e.Link.GetRemoteVideoControl();\r\n\t\t\t((ViewGroup)control.getParent()).removeView(control);\r\n        });\r\n    };\r\n\r\n(Again, note that you can add the control anywhere in the view hierachy. For simplicity, we assume that an empty \"ReceiverContainer\" exists somewhere in your interface definition.)\r\n\r\nLet\u0027s run it again!\r\n\r\n## W00t!\r\n\r\nNow we\u0027re cooking!\r\n\r\nIf all went well, you should have an audio loop (probably with some feedback) as well as a video loop.\r\n\r\nThe local video preview should be pretty crisp and snappy, and the remote video should be slightly lower quality (it\u0027s been compressed, after all) and perhaps a few milliseconds behind.\r\n\r\n## Resources\r\n\r\n* [Frozen Mountain Software](http://www.frozenmountain.com/)\r\n* [IceLink Documentation](http://docs.frozenmountain.com/icelink2/index.html)\r\n* [IceLink Downloads](http://www.frozenmountain.com/downloads#icelink)\r\n* [IceLink Feature Requests](http://support.frozenmountain.com/hc/communities/public/topics/200090149-IceLink-Feature-Requests)\r\n* [IceLink Platform Support](http://www.frozenmountain.com/products/icelink/platforms)\r\n* [IceLink Support](http://support.frozenmountain.com/hc/communities/public/topics/200090139-IceLink-Support)","Hash":"dc62517d2ed0f4e791477b473b9bfdd6","TargetPlatforms":["ios","android"],"TrialHash":null}